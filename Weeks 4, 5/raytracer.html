<!DOCTYPE html>
<!-- saved from url=(0091)file:///C:/Users/Flore/Downloads/CSUMB/CST325/CST325_Homework/Weeks%204,%205/raytracer.html -->
 <html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">	
	<title>Raytracer</title>
</head>
<body>
	<canvas id="my-canvas" width="256" height="256" style="width: 768px; height: 768px;"></canvas>
	<script src="./raytracer_files/vector3.js"></script>
	<script src="./raytracer_files/ray.js"></script>
	<script src="./raytracer_files/sphere.js"></script>
	<script src="./raytracer_files/plane.js"></script>
	<script>
// Canvas setup, don't need to do anything in this section ************************
// Get a reference to the javascript object associated with the canvas
const canvas = document.getElementById('my-canvas');

// The canvas dimension we will set
const pixelsAcross = 256;  // Pixels across
const pixelsDown = 256; // Pixels down

// How much we scale a single pixel.  This has no effect on our computations. Change it to your liking.
const pixelScale = 3;

// Set up the size of our canvas in pixels
canvas.width = pixelsAcross;
canvas.height = pixelsDown;
canvas.style.cssText = 'width:' + (pixelsAcross * pixelScale) + 'px;height:' + (pixelsDown * pixelScale) + 'px';

// Get the context from the canvas (in this case we just want 2d)
const canvasContext = canvas.getContext('2d');

// Get an array representing all of the pixels
// Arranged left to right, top to bottom
const imageData = canvasContext.getImageData(0, 0, pixelsAcross, pixelsDown);
// End canvas setup section *****************************************************

// Raytracer scene data setup ***************************************************
// If this changes, your code should still work
const fov = 45;

let fovRadians = (fov * Math.PI) / 180; // todo -> Convert degrees to radians
let pixelWidth = 2 / pixelsAcross; // todo -> What's the size of a pixel from left to right?
let pixelHalfWidth = pixelWidth / 2; // todo -> Half of the pixel width

// How far away (scalar) the eye is from the image plane (see project guide for more info)
let eyeDistance = 1 / Math.tan(fovRadians / 2); 
// -----------
// |         /
// |        /
// |       /
// | 45/2 /      <---- half angle
// |     /
// |    /
// |   /
// |  /
// | /
let eyeCoordinate = new Vector3(0, 0, eyeDistance); // todo -> set this after eyeDistance is calculated

// Define the scene objects here ------------------

// These are 3d definitions that match all of the math we did in class
// They also provide a "raycast" function that you can pass a ray to in order to find intersection between the ray and the object

let sphere = new Sphere(new Vector3(0, 0, 0), 0.25, new Vector3(1, 1, 1));// todo = new Sphere(...);
// let plane = new Plane(new Vector3(0, 1, 0), new Vector3(0, -0.25, 0)); // todo = new Plane(...);

let floor = new Plane(new Vector3(0, 1, 0), new Vector3(0, -0.25, 0), new Vector3(1, 1, 1));
let ceiling = new Plane(new Vector3(0, -1, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 1));
let leftWall = new Plane(new Vector3(1, 0, 0), new Vector3(-1, 0, 0));
let rightWall = new Plane(new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 1, 0));
let backWall = new Plane(new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(1, 1, 1));

var red = leftWall.color = new Vector3(1, 0, 0);
var green = rightWall.color = new Vector3(0, 1, 0);

let scene = [sphere, ceiling, floor, leftWall, rightWall, backWall];

// End of raytracer setup ******************************************************
// -----------------------------------------------------------------------------
function generateRayForPixel(xPixelIndex, yPixelIndex){
	const pixelX = -1 + pixelHalfWidth + pixelWidth * xPixelIndex;
	const pixelY = 1 - pixelHalfWidth - pixelWidth * yPixelIndex;
	const pixelCoordinate = new Vector3(pixelX, pixelY, 0);
	
	let direction = pixelCoordinate.clone().subtract(eyeCoordinate); // = Vector from the eye to the pixel
	
	// Creates a ray from the eye toward the pixelCoordinate
	let pixelRay = new Ray(eyeCoordinate, direction);; // = new Ray(...);
	return pixelRay;
}
// -----------------------------------------------------------------------------
function setPixelColor(xPixelIndex, yPixelIndex, color /*[0,1]*/){
	const index = (yPixelIndex * pixelsAcross + xPixelIndex) * 4; // 4 bytes per pixel

	const r = Math.max(0, Math.min(1, color.x));
	const g = Math.max(0, Math.min(1, color.y));
	const b = Math.max(0, Math.min(1, color.z));

	imageData.data[index + 0] = r * 255; // Red channel
	imageData.data[index + 1] = g * 255; // Green channel
	imageData.data[index + 2] = b * 255; // Blue channel
	imageData.data[index + 3] = 255;
}
// -----------------------------------------------------------------------------
function updateAndRender(timeElapsed){
	var lightPos = new Vector3(1, 0, 0);
	var seconds = timeElapsed * 0.001; // Convert milliseconds to seconds
	lightPos.x = Math.cos(seconds) * 0.5; // Radius of 0.5
	lightPos.z = Math.sin(seconds) * 0.5; // Radius of 0.5
	
	// Go through every pixel
	// NOTE! You should only call setPixelColor once per pixel.  Otherwise, the last time you call it will be the color and overwrite previous calls.
	for(let yPixelIndex = 0; yPixelIndex < pixelsDown; ++yPixelIndex){
		for(let xPixelIndex = 0; xPixelIndex < pixelsAcross; ++xPixelIndex){
			// Uncomment this once you've coded generateRayForPixel
			const pixelRay = generateRayForPixel(xPixelIndex, yPixelIndex);
			
			// See if the ray intersects the sphere or the plane (or every object in our scene)
			// Uncomment when your sphere or plane code is ready
			
			// const sphereResult = sphere.raycast(pixelRay);
			// const planeResult = plane.raycast(pixelRay);
			
			// Determine which hit object is the closest (in case there is more than 1 hit)
			let closestHit = null;
			let closestObj = null;

			for(let i = 0; i < scene.length; i++){
				const r = scene[i].raycast(pixelRay);
				if(r.hit){
					if(!closestHit || r.distance < closestHit.distance){
						closestHit = r;
						closestObj = scene[i];
					}
				}
			}
			if(!closestHit){
				setPixelColor(xPixelIndex, yPixelIndex, new Vector3(0.1, 0.1, 0.1));
			}else{
				let lightDir = lightPos.clone().subtract(closestHit.point).normalize();
				let shade = Math.max(0, closestHit.normal.dot(lightDir));
				if(shade < 0){
					shade = 0;
				}
				if(isInShadow(closestHit.point, lightPos, closestObj, scene)){
					shade = 0.0;
				}
				const objClr = (closestObj.color instanceof Vector3) ? closestObj.color : new Vector3(1, 1, 1);
				const finalClr = objClr.clone().multiplyScalar(shade);
				setPixelColor(xPixelIndex, yPixelIndex, finalClr);
			}
		}
	}
	// Take our array of color data and give to the canvas to display
	canvasContext.putImageData(imageData, 0, 0);
	
	// Let the browser know it should call this function again when it's time to render
	requestAnimationFrame(updateAndRender);
}
// -----------------------------------------------------------------------------
function isInShadow(hitPoint, lightPos, hitObject, scene){
	var toLight = lightPos.clone().subtract(hitPoint);
	var distToLight = toLight.length();
	var lightDir = toLight.clone().normalize();
	
	var shadowOrigin = hitPoint.clone().add(lightDir.clone().multiplyScalar(0.005));
	var shadowRay = new Ray(shadowOrigin, lightDir);
	
	for(let i = 0; i < scene.length; i++){
		const obj = scene[i];
		if(obj === hitObject){
			continue;
		}
		const r = obj.raycast(shadowRay);
		if(r.hit && r.distance < distToLight){
			return true;
		}
	}
	return false;
}
// -----------------------------------------------------------------------------
// We are ready to render, let the browser know
requestAnimationFrame(updateAndRender);
</script>
<script src="./raytracer_files/raytracer-tests.js"></script>
</body></html>